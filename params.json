{
  "name": "Sonarqube",
  "tagline": "SonarQube - Tech Talk",
  "body": "# SonarQube \r\n\r\n**Presented By**\r\n\r\nRahul Coutinho (rcoutin)  \r\nRohil Shah (rshah8)  \r\nSiddhant Shah (sshah14)  \r\nVijay Hebbar (vhhebbar)  \r\n\r\nSonarqube is a Continuous Inspection framework that provides insight on the Code Quality characteristics of source code. It performs static analysis on code to detect bugs, code smells, duplicated code and security vulnerabilities, and provides descriptive review comments automatically. Its vast array of plugins adds support for a variety of programming languages and integration to a majority of DevOps platforms.\r\n\r\nHere are some of the features that Sonarqube offers - \r\n\r\n* **Deep code analysis:** SonarQube, through SonarCloud, can explore all your source files, whether in branches or pull requests, to reach a green quality gate and promote the build. This makes it really handy to use in huge teams where each team commits to a separate branch, so that the code can be properly analyzed before it can be merged into the master branch.\r\n* **Centralized Dashboard** - An interface that provides a unified status of the projects code quality trends. It provides historical information that helps visualize the code quality characteristics over time. It also quantifies the amount of time required to resolve an issue i.e. 'CodeDebt'. \r\n* **QualityGate** - Customize parameters that gauge the quality of code, as per your organizational thresholds. \r\n* **Vast Collection of Rules** - Thanks to powerful static code analyzers, you can monitor an array of rules and can easily track down bugs and other quality issues.\r\n* **External Integration** - Sonarqube integrates well with several popular Build Systems like Maven, Gradle and Ant, and Continuous Integration Engines like Jenkins, Travis CI, AppVeyor and more.    \r\n* **REST API** - Sonarqube's REST API can be used to automatically provision a SonarQube project and also monitor the analysis process. \r\n* **Fast and Scalable:** SonarQube has been tested in various environments. It performs daily analysis on more than five thousand projects with more than four million lines of code and twenty developers. \r\n* **Support for 16 languages:** It supports a variety of languages like Java, JS, C#, C/C++, Objective-C, TypeScript, Python, ABAP, PLSQL, T-SQL etc, so it is pretty flexible and can be appied over an array of projects.  \r\n\r\n### Limitations\r\n* **Cost:** Its greatest con is its plugins cost in regards to certain languages, as well as the cost of licensing the enterprise model. Developers who produce millions of lines of code a year will be shelling out up to $62,000 per year to use the software, depending on output, and costs per year for huge, high availability database applications could reach $1 million per year\r\n* **SonarQube does not build projects:** There are several tools out there like Maven, Ant, Gradle etc. that do a perfect job on that field. SonarQube expects that before you analyze a project it has been already compiled and built by your favorite build tool.\r\n\r\n### What it is not!\r\n\r\n* **SonarQube is not a code coverage tool:** It is integrated with the most popular test coverage tools like JaCoCo, Cobertura, PHPUnit etc. but it does not compute code coverage itself. It reads pre-generated unit test report files and displays them in an extremely convenient dasboard.\r\n* **SonarQube is not a code formatter:** It is not allowed to modify your code in any way. However, you can get formatting suggestions by enabling the CheckStyle, CPPCheck, ScalaStyle rules you want to follow.\r\n* **SonarQube is not a continuous integration system to run your nightly builds:** You can integrate it with the most popular CI Engines to apply Continuous Inspection but it’s not their replacement.\r\n\r\n### Components\r\n\r\nSonarQube offers the following components that can be mixed and matched as per user requirements.\r\n\r\n**SonarQube Server** \r\n\r\nThe SonarQube server acts as an in-depth, yet user-friendly, dashboard for viewing code quality characteristics of projects. Internally, it is a collection of backend servers that enable developers, managers to visualize quality snapshots and configure the SonarQube instance. It consists of a Search Server based on ElasticSearch to back searches from the UI, and a Compute Engine Server in charge of processing code analysis reports and saving them in the SonarQube Database. The database also stores the configuration of the SonarQube instance (security, plugins settings, etc.) and the quality snapshots of projects, views, etc.\r\n   \r\nAdditionally, the server may also contain multiple **SonarQube Plugins**, including language, SCM, integration, authentication, and governance plugins. The REST API is also exposed by the server. \r\n \r\nThese components are readily available to the user as a package from the [download page](https://www.sonarqube.org/downloads/)\r\n\r\n**SonarCloud** \r\n\r\nSonarCloud is a cloud-based alternative to the SonarQube server. It has all the features that the SonarQube server has to offer in addition to the minimal overhead of maintenance. SonarCloud is free for use with public repositories. \r\n\r\n**SonarQube Scanner** \r\n\r\nThe SonarQube Scanner is the underlying computation engine that performs the static analysis of code. The above servers rely on data from the scanner. This scanner could be downloaded as a stand-alone application or used as a plugin on your Build / Continuous Integration Servers.\r\n\r\nSonarqube requirements are briefly mentioned [here](./requirements.md).\r\nSonarqube step-by-step installation guide is available [here](./setup.md).\r\n\r\n## Integrating SonarQube with various CI Engines (Demonstration [SonarQube TechTalk-Youtube](https://youtu.be/_HaeXszIZOE))\r\n### 1. Analyzing with SonarQube Scanner for Jenkins\r\nFor integrating SonarQube Scanner for Jenkins, we use the SonarQube Scanner for Jenkins 2.6.1. This plugin lets you centralize the configuration of SonarQube server connection details in Jenkins global configuration. Then you can trigger SonarQube analysis from Jenkins using standard Jenkins Build Steps to trigger analysis with:\r\n* SonarQube Scanner\r\n* SonarQube Scanner for Maven\r\n* SonarQube Scanner for MSBuild\r\n\r\nOnce the job is complete, the plugin will detect that a SonarQube analysis was made during the build and display a badge and a widget on the job page with a link to the SonarQube dashboard as well as quality gate status. \r\n\r\n[Here](https://github.ncsu.edu/rcoutin/SonarQube/blob/master/SonarQubeWithJenkins.md) you can find a step-by-step procedure to integrate SonarQube with Jenkins to run unit test cases and publish results to SonarQube.\r\n\r\n### 2. Analyzing with SonarQube Scanner for Maven\r\nThis analyzer is recommended to launch analysis on Java Maven project.\r\n\r\n**Compatibility**: Maven 3.x\r\n\r\n**Prerequisites**:\r\n* Maven 3.x\r\n* SonarQube is already [installed](https://docs.sonarqube.org/display/SONAR/Installing+the+Server)\r\n* At least the minimal version of Java supported by your SonarQube server is in use (Java 8 for latest LTS)\r\n* The language plugins for each of the languages you wish to analyze are installed\r\n* You have read [Analyzing Code Source](https://docs.sonarqube.org/display/SONAR/Analyzing+Source+Code). \r\n\r\n**Initial Setup**\r\nEdit the settings.xml file, located in $MAVEN_HOME/conf or ~/.m2 or /etc/maven/, to set the plugin prefix and optionally the SonarQube server URL.\r\n\r\nExample: \r\n```\r\n<settings>\r\n    <pluginGroups>\r\n        <pluginGroup>org.sonarsource.scanner.maven</pluginGroup>\r\n    </pluginGroups>\r\n    <profiles>\r\n        <profile>\r\n            <id>sonar</id>\r\n            <activation>\r\n                <activeByDefault>true</activeByDefault>\r\n            </activation>\r\n            <properties>\r\n                <!-- Optional URL to server. Default value is http://localhost:9000 -->\r\n                <sonar.host.url>\r\n                  http://myserver:9000\r\n                </sonar.host.url>\r\n            </properties>\r\n        </profile>\r\n     </profiles>\r\n</settings>\r\n```\r\n\r\n**Analyzing a Maven Project**\r\nAnalyzing a Maven project consists of running a Maven goal: sonar:sonar in the directory where the pom.xml file sits.\r\n```\r\nmvn clean verify sonar:sonar\r\n  \r\n# In some situation you may want to run sonar:sonar goal as a dedicated step. Be sure to use install as first step for multi-module projects\r\nmvn clean install\r\nmvn sonar:sonar\r\n```\r\n### 3. Continuous Inspection with TravisCI \r\n\r\nTravisCI offers a SonarCloud plugin that allows for static code analysis on every commit, thus enabling Continuous Inspection. This integration also enables automatic review comments in pull requests.\r\n\r\nA brief summary of steps have been outlined below with links to detailed documentation\r\n\r\n* **Setup SonarCloud**   \r\n   * Register to SonarCloud at www.sonarcloud.io  \r\n   * Create an Organization, note its name and key  \r\n   * Create a [User authentication token](https://sonarcloud.io/account/security) on SonarCloud and keep it handy  \r\n* [**Enable Travis Integration**](https://docs.travis-ci.com/user/sonarcloud/)  \r\n   * Create a .travis.yml file : This tells Travis that the SonarCloud addon has to be used and what parameters it needs.  \r\n   * Create a sonar-project.properties file to configure the scanner properties like project-key and project-name\r\n* [**Enable Pull Request reviews**](https://docs.travis-ci.com/user/sonarcloud/#Analysis-of-internal-pull-requests)  \r\n   * Create a new GitHub account for the bot that SonarCloud will use to comment on Pull Requests and add it as a collaborator on your project. \r\n   * Obtain a [Personal Access Token](https://help.github.com/articles/creating-an-access-token-for-command-line-use/) from the Developer Settings and set access permissions.   \r\n   * Login to SonarCloud; Configure the Pull Request settings\r\n   \r\n Sample configuration files are available [here](TravisCI_Config_Sample)\r\n\r\n**Limitations**  \r\n* The current version can only scan Internal pull requests. External Pull Requests will be added in future versions. \r\n* Since the TravisCI SonarCloud addon communicates directly to the host 'www.sonarcloud.io' it is challenging to add a custom SonarQube server to scan Private repository. This means private repositories have to be scanned at a cost, on SonarCloud instead your own SonarQube instance.\r\n\r\n## Insights\r\n\r\nWe first came across SonarQube while developing our Software Engineering project. We had decided to develop a chat bot that performs static code analysis and gives the user suggestions and ways to make his/her code better. We researched many static code analysis tools and found SonarQube to be the easiest to implement with its open-source nature, extensive plugins and integrations with other software, integrated Web APIs, a good UI for the server and detailed installation and troubleshooting documents and forums available.\r\n\r\nSonarQube's RESTful API makes it easier for apps to communicate with the SonarQube server to receive analysis reports and rules information pertaining to the issues in the code.\r\n\r\nA poster and URL of our project can be found below.\r\n\r\n![poster](https://github.ncsu.edu/rcoutin/SonarQube/blob/master/content/poster_v4.jpg?raw=true)\r\nProject Page: [TutorBot](https://pages.github.ncsu.edu/rcoutin/BOT/)\r\n\r\n## Why Static Code Analysis at all[?](http://javarevisited.blogspot.com/2014/02/why-static-code-analysis-is-important.html)\r\n\r\nStatic code analysis is about analysing your source code without executing them to find potential vulnerabilities, bugs and security threats. Software code quality and security has went from being a “nice to have” to a necessity, and many organizations are making it mandatory to pass static code analysis test, penetration testing and security testing before you deploy your code in production. Static analysis tools are getting popular every passing day and more and more companies are making static code analysis scan mandatory for all new development.\r\n\r\nStatic code analyser looks for patterns, defined to them as rules, which can cause those security vulnerability or other code quality problems, necessary for production quality code. But like every other technology, static analysis has it’s set of advantages and disadvantages, which is also best way to judge any technology.\r\n\r\nAs a senior Java developer or Team lead, you have responsibility to set-up process like automated code analysis, continuous integration, automation testing to keep your project in healthy state and promote best development practices in your team.\r\n\r\nIn our opinion, unit testing, code review and static code analysis makes a nice combo, along with continuous integration. But as every tool has some pros and cons, here are some cons of using static code analysis tools:\r\n\r\n* **Time Consuming**:\r\nAnother problem with static code analysers is that they take too long to run and after some time developers never bother to run them. You can minimize this problem by making static code analysis part of your build process, and not an optional, good to do alternative. Second thing, you must review and write custom rules, so that it won't take too long to execute. Given build process need to do too many things these days e.g. clean, compile, package, static analysis, unit testing and deployment, even small time added in each step, eventually increases total build time.\r\n* **False Positives**: \r\nWhen your tools alert you with false positives, you start taking them lightly and then it becomes habit to treat everything as a false positive, which eventually takes away all benefits of static code analysis. A good software developer needs to be disciplined enough to not fall into that trap.\r\n\r\n\r\n\r\n## Other Static Analysis Tools\r\n\r\nWe looked at other Static Analysis tools; some of them, like Checkmarx and Veracode were too security-focused and had limited options in terms of language support and DevOps integration. Standalone code analyzers like PMD, CheckStyle and FixBugs did not feature an extensive analysis insights and DevOps support. Coverity came close to SonarQube with respect to language support and DevOps integration but it was soon evident that SonarQube had superior user experience, post-analysis reports and documentation. Codacy also offered a similar feature set, and seemed like a scaled-down version of SonarQube; it did not feature a standalone scanner component. CodeClimate, which is more popular than SonarQube, has a smaller learning curve and simpler integration with external services, but it's quality gate and rule-set were less granular than SonarQube. CodeFactor also had similar limitations, but it had an interesting feature - code performance review.\r\n\r\nIn conclusion, SonarQube is vastly flexible as compared to its rivals; its cloud interface, SonarCloud makes it easier to get things up and running, whereas the standalone Scanner and Server components meets more complex requirements. Moreover, SonarQube's rich analysis insights and granular configuration should appeal to advanced users.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}